import { MessageModel } from '../message/messageModel';
import { Logger } from '../../common/definitions';
import { MessageFactory, NonRawMessage } from '../../lib2';
/**
 * Wrapper object for accessing nlpresult
 */
export declare class NLPResult {
    private _nlpresult;
    constructor(nlpresult: any);
    /**
     * Returns matches for the specified entity; may be an empty collection.
     * If no entity is specified, returns the map of all entities.
     * @param {string} [entity] - name of the entity
     * @return {object} The entity match result.
     */
    entityMatches(entity?: any): any;
    /**
     * Returns full payload matches for the specified entity; may be an empty collection.
     * If no entity is specified, returns the full payload map of all entities.
     * @param {string} [entity] - name of the entity
     * @return {object} The full entity match result.
     */
    fullEntityMatches(entity?: string): any;
    /**
     * Returns intent matches if any.
     * Intent matches are returned in descending order of score
     * @return {object[]} The intent match results, each match with properties score and intent.
     */
    intentMatches(): any;
    /**
     * Returns top intent match (with highest score), if any.
     * @return {object} The top intent match (with properties score and intent)
     */
    topIntentMatch(): any;
    query(): any;
}
/**
 * Super class for concrete context classes used to invoke custom components
 * and event handlers
 */
export declare abstract class BaseContext {
    protected readonly _request: any;
    protected readonly _response: any;
    protected readonly _logger: Logger;
    /**
     * @param {object} request - invocation request payload
     * @param {object} response - initial response payload
     * @param {Function} [validationSchema] - callback returns a schema for request body validation
     */
    constructor(request: any, response: any, validationSchema?: (joi: any) => any);
    /**
     * Retrieves the request object.
     * @return {object} The request object.
     */
    getRequest(): any;
    /**
     * Retrieves the response object.
     * @return {object} The response object.
     */
    getResponse(): any;
    /**
     * Retrieves the logger object.
     * @return {object} The logger object.
     */
    logger(): Logger;
    /**
     * Retrieves the logger object.
     * @return {object} The logger object.
     * @deprecated use logger() function instead
     */
    getLogger(): Logger;
    /**
   * Returns an NLPResult helper object for working with nlpresult variables.
   * See the NLPResult documentation for more information.
   * <p>
   * If your skill uses visual flows, you don't need to specify a variable name.
   * If your skill uses a YAML flow, you may specify a particular nlpresult by name (if you have multiple
   * nlpresult variables defined in the flow), or omit the name if you only have 1 nlpresult.
   * </p>
   *
   * @param {string} [nlpVariableName] - variable that holds the nlpResult
   * @return {NLPResult} The nlp resolution result.
   */
    nlpResult(nlpVariableName?: string): NLPResult;
    /**
     * Read or write variables defined in the current flow.
     * It is not possible to change the type of an existing variable through
     * this method.  It is the caller's responsibility to ensure that the
     * value being set on a variable is of the correct type. (e.g. entity,
     * string or other primitive, etc).
     * <p>
     * A new variable can be created.  However, since the variable is not
     * defined in the flow, using it in the flow subsequently may be flagged
     * for validation warnings.
     * </p>
     * This function takes a variable number of arguments.
     * <p>
     * The first form:
     * variable(name);
     * reads the variable called "name", returning its value.
     * The name could be in the form of &lt;scope&gt;.&lt;variableName&gt;.  For example, a variable firstName in the
     * profile scope needs to be retrieved as variable("profile.firstName").
     * </p>
     * The second form:
     * variable(name, value);
     * writes the value "value" to the variable called "name".
     *
     * @param {string}  name - The name of variable to be set or read
     * @param {*} [value] - value to be set for variable
     * @example
     *  let firstName = conversation.variable("profile.firstName");
     *  let lastName = conversation.variable("profile.lastName");
     *  conversation.variable("fullName", firstName + ' ' + lastName);
     */
    variable(name: string, value?: any): any | this;
    /**
     * Get the definition of a variable
     *
     * @param {string} name - The name of the variable
     */
    getVariableDefinition(name: string): any;
    /**
     * Returns the value of a context or user variable
     * @return {object} variable value
     * @param {string} name - name of the variable
     */
    getVariable(name: any): any;
    /**
     * Sets the value of a context or user variable
     * @param {string} name - name of the variable
     * @param {object} value - value of the variable
     */
    setVariable(name: any, value: any): this;
    /**
     * Get translated string using a resource bundle key defined in the skill.
     * @return {string} resource bundle freemarker expression that will be resolved when event handler or custom component response is
     * received by dialog engine
     * @param {string} rbKey - key of the resource bundle entry defined with the skill that should be used to translate
     * @param {string} rbArgs - substitution variables
     */
    translate(rbKey: string, ...rbArgs: string[]): string;
    /**
     * Return the channel conversation type
     * @return {string} the channel type
     */
    getChannelType(): string;
    /**
     * Returns the last user message.
     * @return {NonRawMessage} the last user message. You can cast this message to the appropriate message type.
     */
    getUserMessage<T extends NonRawMessage>(): T;
    /**
     * Returns the MessageModel class for creating or validating messages to or from bots.
     * @return {MessageModel} The MessageModel class
     * @deprecated Use getMessageFactory() instead
     */
    getMessageModel(): typeof MessageModel;
    /**
     * Returns the MessageFactory class for creating bots messages
     * @return {MessageFactory} The MessageFactory class
     */
    getMessageFactory(): typeof MessageFactory;
    /**
     * Creates a message payload object
     * @param {object} payload - can take a string message, a message created by the MessageFactory, or a message created by the
     * deprecated MessageModel.
     * @returns {object} message payload in JSON format
     */
    constructMessagePayload(payload: any): any;
}
