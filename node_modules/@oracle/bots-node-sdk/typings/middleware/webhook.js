"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookClient = exports.WebhookEvent = void 0;
const constants_1 = require("../common/constants");
const util_1 = require("../util/");
const message_1 = require("../lib/message");
const codes_1 = require("./codes");
var WebhookEvent;
(function (WebhookEvent) {
    /** Error event */
    WebhookEvent[WebhookEvent["ERROR"] = 1] = "ERROR";
    /** Event dispatched when message is sent to bot */
    WebhookEvent[WebhookEvent["MESSAGE_SENT"] = 2] = "MESSAGE_SENT";
    /** Event dispatched when message is received from bot */
    WebhookEvent[WebhookEvent["MESSAGE_RECEIVED"] = 3] = "MESSAGE_RECEIVED";
})(WebhookEvent = exports.WebhookEvent || (exports.WebhookEvent = {}));
class WebhookClient {
    constructor(options) {
        this._subscriptions = new Map();
        this._options = options || {};
        // prepare event subscription map
        Object.keys(WebhookEvent)
            .filter(key => ~~key) // non-zero integer only
            .forEach((eventType) => {
            this._subscriptions.set(`${eventType}`, new Set());
        });
    }
    _getSubscriptions(event) {
        const subs = this._subscriptions.get(`${event}`);
        if (!subs) {
            throw new Error(`Invalid webhook event type, '${event}'`);
        }
        return subs;
    }
    _dispatch(event, args) {
        this._getSubscriptions(event)
            .forEach(handler => handler.apply(handler, [].concat(args)));
    }
    _getChannelConfig(req) {
        const { channel } = this._options;
        return Promise.resolve(typeof channel === 'function' ? channel(req) : channel)
            .then(config => {
            // ensure backwards compatibility with webhookReceiver configuration (secret only callback)
            return typeof config === 'object' ? config : {
                url: null,
                secret: config
            };
        });
    }
    on(event, handler) {
        this._getSubscriptions(event).add(handler);
        return this;
    }
    /**
     * Send user message to bot
     * @param message - Complete payload to send
     * @param channel - Webhook channel configuration to use (if different than that in the instance options)
     */
    send(message, channel) {
        return Promise.resolve(channel || this._getChannelConfig())
            .then(webhook => new Promise((resolve, reject) => {
            if (message) {
                try {
                    const { url, secret } = webhook;
                    const { userId, messagePayload } = message, extras = __rest(message, ["userId", "messagePayload"]);
                    util_1.webhookUtil.messageToBotWithProperties(url, secret, userId, messagePayload, extras, error => error ? reject(error) : resolve(true));
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                resolve(null);
            }
        }))
            .then(sent => sent && this._dispatch(WebhookEvent.MESSAGE_SENT, message))
            .catch(e => {
            // dispatch errors
            this._dispatch(WebhookEvent.ERROR, e);
            return Promise.reject(e);
        });
    }
    /**
     * Webhook receiver middleware.
     * @param callback - callback on message received, otherwise emits event
     */
    receiver(callback) {
        return (req, res, next) => {
            // Validate message from bot
            this._receiverValidationHandler()(req, res, err => {
                // respond to the webhook request.
                if (err) {
                    this._dispatch(WebhookEvent.ERROR, err);
                    // TODO: standardize response for bots platform
                    res.json({ ok: false, error: err.message }); // status code is already set.
                }
                else {
                    // invoke callback or dispatch to bot response subscribers
                    if (callback) {
                        callback(req, res, next);
                    }
                    else {
                        this._dispatch(WebhookEvent.MESSAGE_RECEIVED, req.body);
                        res.json({ ok: true });
                    }
                }
            });
        };
    }
    /**
     * webhook request validation. supported either as middleware layer, or
     * receiver callback
     */
    _receiverValidationHandler() {
        return (req, res, cb) => {
            return this._getChannelConfig(req)
                .then(channel => {
                if (channel) {
                    const body = req[constants_1.CONSTANTS.PARSER_RAW_BODY]; // get original raw body
                    const encoding = req[constants_1.CONSTANTS.PARSER_RAW_ENCODING]; // get original encoding
                    const signature = req.get(constants_1.CONSTANTS.WEBHOOK_HEADER); // read signature header
                    if (!signature) {
                        res.status(codes_1.STATUS_CODE.BAD_REQUEST);
                        return Promise.reject(new Error(`${constants_1.CONSTANTS.WEBHOOK_HEADER} signature not found`));
                    }
                    const valid = util_1.webhookUtil.verifyMessageFromBot(signature, body, encoding, channel.secret);
                    if (!valid) {
                        res.status(codes_1.STATUS_CODE.FORBIDDEN);
                        return Promise.reject(new Error('Signature Verification Failed'));
                    }
                }
                else {
                    res.status(codes_1.STATUS_CODE.BAD_REQUEST);
                    return Promise.reject(new Error('Missing Webhook Channel SecretKey'));
                }
                return;
            })
                .then(cb) // passing callback
                .catch(cb); // cb with failure
        };
    }
    /**
     * Returns the MessageModel class for creating or validating messages to or from bots.
     */
    MessageModel() {
        return message_1.MessageModel;
    }
}
exports.WebhookClient = WebhookClient;
